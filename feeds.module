<?php

/**
 * @file
 * Feeds - basic API functions and hook implementations.
 */

use Drupal\Core\Datetime\DrupalDateTime;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Render\Element;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Template\Attribute;
use Drupal\Core\Url;
use Drupal\feeds\Entity\Feed;
use Drupal\feeds\Entity\Importer;
use Drupal\feeds\FeedInterface;
use Drupal\feeds\StateInterface;
use GuzzleHttp\Exception\BadResponseException;
use GuzzleHttp\Exception\RequestException;
use Zend\Feed\Reader\Reader;

/**
 * Implements hook_help().
 */
function feeds_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'feeds.importer_list':
      return '<p>' . t('Create one or more Feed importers for pulling content into Drupal.') . '</p>';
  }
}

/**
 * Entity URI callback.
 *
 * @param \Drupal\Core\Entity\EntityInterface $feed
 *   A feed entity.
 *
 * @return array
 *   An array with 'path' as the key and the path to the node as its value.
 */
function feeds_feed_uri(EntityInterface $feed) {
  return array(
    'path' => 'feed/' . $feed->id(),
  );
}

/**
 * Implements hook_cron().
 */
function feeds_cron() {
  $queue = \Drupal::queue('feeds_feed_import');

  $ids = \Drupal::entityQuery('feeds_feed')
    ->condition('queued', 0)
    ->condition('next', REQUEST_TIME, '<=')
    ->condition('next', -1, '<>')
    ->range(0, 100)
    ->sort('imported')
    ->execute();

  foreach (Feed::loadMultiple($ids) as $feed) {
    if ($feed->isLocked()) {
      continue;
    }
    if ($queue->createItem($feed)) {
      // Add timestamp to avoid queueing item more than once.
      $feed->setQueuedTime(REQUEST_TIME);
      $feed->save();
    }
  }

  // Delete queued timestamp after 12 hours assuming the update has failed.
  $ids = \Drupal::entityQuery('feeds_feed')
    ->condition('queued', REQUEST_TIME - (3600 * 12), '<')
    ->execute();

  foreach (Feed::loadMultiple($ids) as $feed) {
    $feed->setQueuedTime(0);
    $feed->save();
  }
}

/**
 * Scheduler callback for unsubscribing from PuSH hubs.
 *
 * @todo Perform actual unsubscribe.
 */
function feeds_push_unsubscribe(array $job) {
  $subscription = \Drupal::service('feeds.subscription.crud')->getSubscription($job['id']);

  // Do the unsubscribe dance.

  \Drupal::service('feeds.subscription.crud')->deleteSubscription($job['id']);
}

/**
 * Scheduler callback for subscribing from PuSH hubs.
 */
function feeds_push_subscribe($fid) {
  if (!$feed = entity_load('feeds_feed', $fid)) {
    return;
  }
  if (!$subscription = \Drupal::service('feeds.subscription.crud')->getSubscription($feed->id())) {
    return;
  }

  // @todo Error handling.
  $feed_string = \Drupal::httpClient()
    ->get($feed->getSource())
    ->getBody(TRUE);

  Reader::setExtensionManager(Drupal::service('feed.bridge.reader'));
  $channel = Reader::importString($feed_string);

  if (!$hubs = $channel->getHubs()) {
    return;
  }

  $subscription['hub'] = reset($hubs);
  $subscription['state'] = 'subscribe';
  \Drupal::service('feeds.subscription.crud')->setSubscription($subscription);

  try {
    \Drupal::httpClient()
      ->post($subscription['hub'])
      ->addPostFields(array(
        'hub.callback' => Url::createFromPath('feed/' . $feed->id() . '/push_callback')->setAbsolute()->toString(),
        'hub.callback' => 'http://twistor.me',
        'hub.mode' => $subscription['state'],
        'hub.topic' => $subscription['topic'],
        'hub.verify_token' => $subscription['token'],
        'hub.verify' => 'sync',
        'hub.lease_seconds' => '',
        'hub.secret' => $subscription['secret'],
      )
    );
  }
  catch (BadResponseException $e) {
    $response = $e->getResponse();
    watchdog('feeds', '%error', array('%error' => $response->getStatusCode() . ' ' . $response->getReasonPhrase()), WATCHDOG_WARNING);
  }
  catch (RequestException $e) {
    watchdog('feeds', '%error', array('%error' => $e->getMessage()), WATCHDOG_WARNING);
  }

  if ($response->getStatusCode() != 204 || $response->getStatusCode() != 202) {
    // There was an error, handle it.
  }
}

/**
 * Implements hook_theme().
 */
function feeds_theme() {
  return array(
    'feeds_feed_status' => array(
      'variables' => array(
        'progress_importing' => NULL,
        'progress_clearing' => NULL,
        'imported' => NULL,
        'count' => NULL,
      ),
      'file' => 'feeds.theme.inc',
    ),
    'feeds_feed' => array(
      'render element' => 'elements',
      'template' => 'feeds_feed',
    ),
  );
}

/**
 * Prepares variables for feed templates.
 *
 * Default template: feeds_feed.html.twig.
 *
 * Most themes utilize their own copy of feeds_feed.html.twig. The default is
 * located inside "modules/feeds/templates/feeds_feedhtml.twig". Look in there
 * for the full list of variables.
 *
 * @param array $variables
 *   An associative array containing:
 *   - elements: An array of elements to display in view mode.
 *   - feed: The feed object.
 *   - view_mode: View mode; e.g., 'full', 'teaser'...
 */
function template_preprocess_feeds_feed(&$variables) {
  $variables['view_mode'] = $variables['elements']['#view_mode'];
  $variables['feed'] = $feed = $variables['elements']['#feeds_feed'];

  $variables['page'] = $variables['view_mode'] === 'full';

  $variables['date'] = drupal_render($variables['elements']['created'], TRUE);
  unset($variables['elements']['created']);
  $variables['author_name'] = drupal_render($variables['elements']['uid'], TRUE);
  unset($variables['elements']['uid']);

  $variables['url'] = $feed->url('canonical', array(
    'language' => $feed->language(),
  ));
  $variables['label'] = $variables['elements']['title'];
  unset($variables['elements']['title']);

  // Helpful $content variable for templates.
  $variables += array('content' => array());
  foreach (Element::children($variables['elements']) as $key) {
    $variables['content'][$key] = $variables['elements'][$key];
  }

  // Used by RDF to add attributes around the author and date submitted.
  $variables['author_attributes'] = new Attribute();

  // Add article ARIA role.
  $variables['attributes']['role'] = 'article';
  $variables['item_count'] = $feed->getItemCount();
}


/**
 * Implements hook_file_download().
 *
 * @todo This doesn't handle duplicate sources.
 */
function feeds_file_download($uri) {
  $fids = \Drupal::entityQuery('feeds_feed')
    ->condition('source', $uri)
    ->range(0, 1)
    ->execute();

  if (!$fids) {
    // File is not associated with a feed.
    return;
  }

  // Get the file record based on the URI. If not in the database just return.
  $files = file_load_multiple(array(), array('uri' => $uri));
  foreach ($files as $item) {
    // Since some database servers sometimes use a case-insensitive comparison
    // by default, double check that the filename is an exact match.
    if ($file->getFileUri() === $uri) {
      $file = $item;
      break;
    }
  }
  if (!isset($file)) {
    return;
  }

  // Check if this file belongs to Feeds.
  $usage_list = file_usage()->listUsage($file);
  if (!isset($usage_list['feeds'])) {
    return;
  }

  $fid = reset($fids);

  $feed = \Drupal::entityManager()->getStorage('feeds_feed')->load($fid);
  if (!$feed || !$feed->access('import')) {
    // User does not have permission to import this feed.
    return -1;
  }

  // Return file headers.
  return file_get_content_headers($file);
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Remove our field from the Field UI overview form.
 */
function feeds_form_field_ui_field_overview_form_alter(array &$form, FormStateInterface $form_state) {
  // if (in_array('feeds_item', $form['#fields'])) {

  //   unset($form['#fields'][array_search('feeds_item', $form['#fields'])]);
  //   unset($form['fields']['feeds_item']);

  //   $rows_order = $form['fields']['#regions']['content']['rows_order'];
  //   $key = array_search('feeds_item', $rows_order);
  //   unset($form['fields']['#regions']['content']['rows_order'][$key]);
  // }
}
